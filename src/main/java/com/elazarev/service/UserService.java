package com.elazarev.service;

import com.elazarev.domain.Question;
import com.elazarev.domain.Tag;
import com.elazarev.domain.User;
import com.elazarev.exceptions.ForbiddenResourceException;
import com.elazarev.exceptions.ResourceNotFoundException;
import com.elazarev.repository.RoleRepository;
import com.elazarev.repository.UserRepository;
import com.elazarev.exceptions.UserAlreadyExistsException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

import java.security.Principal;
import java.util.Optional;

/**
 * Class for Users business logic.
 * @author Eugene Lazarev mailto(helycopternicht@rambler.ru)
 * @since 14.02.18
 */
@Service
public class UserService {
    /**
     * How match users shown per page.
     */
    public static final int MAX_USERS_PER_PAGE = 10;
    /**
     * Users repository to persist users.
     */
    private UserRepository repo;
    /**
     * Role repository.
     */
    private RoleRepository roleRepo;
    /**
     * Tags service.
     */
    private TagsService tagsService;

    /**
     * Constructor with all of dependencies.
     * @param repo user repository impl.
     * @param roleRepo role repository impl.
     * @param tagsService tag service.
     */
    @Autowired
    public UserService(UserRepository repo, RoleRepository roleRepo, TagsService tagsService) {
        this.repo = repo;
        this.roleRepo = roleRepo;
        this.tagsService = tagsService;
    }

    /**
     * Return user with specified login.
     * @param name login to find.
     * @return user with specified login.
     * @throws ResourceNotFoundException if user with this name is not found.
     */
    public User findByLogin(String name) throws ResourceNotFoundException {
        Optional<User> user = repo.findUserByLogin(name);
        return user.orElseThrow(() -> new ResourceNotFoundException("User with name " + name + "not found"));
    }

    /**
     * Returns user for specified principal.
     * @param p principal to get user.
     * @return user
     * @throws ForbiddenResourceException if principal is not present.
     */
    public User getUser(Principal p) throws ForbiddenResourceException {
        if (p == null) {
            throw new ForbiddenResourceException("You are not authorized");
        }
        return findByLogin(p.getName());
    }

    /**
     * Returns page of users from repository.
     * @param page page number.
     * @return page of users.
     * @throws ResourceNotFoundException if page has not data.
     */
    public Page<User> getPage(Optional<Integer> page) throws ResourceNotFoundException {
        Pageable p = PageRequest.of(page.orElse(1) - 1, MAX_USERS_PER_PAGE, Sort.Direction.DESC, "id");
        Page<User> currentPage = repo.findAll(p);
        if (!currentPage.hasContent()) {
            throw new ResourceNotFoundException("page not found");
        }
        return currentPage;
    }

    /**
     * Persist user in repository.
     * @param u user to persist.
     * @return user with updated autogenerated fields.
     * @throws UserAlreadyExistsException if user with same login already presented.
     */
    public User createUser(User u) throws UserAlreadyExistsException {
        if (repo.findUserByLogin(u.getLogin()).isPresent()) {
            throw new UserAlreadyExistsException("User already exists - login: " + u.getLogin());
        }
        u.getRoles().add(roleRepo.findByName(RoleRepository.ROLE_NAME_USER));
        return repo.save(u);
    }

    /**
     * Save changed user.
     * @param u user to save.
     */
    private void save(User u) {
        repo.save(u);
    }

    /**
     * Update current user fields if they changed.
     * @param source changed user.
     * @param p current user.
     */
    public void saveOnlyChangedFields(User source, Principal p) {
        User receiver = getUser(p);

        if (!receiver.getFirstName().equals(source.getFirstName())) {
            receiver.setFirstName(source.getFirstName());
        }
        if (!receiver.getLastName().equals(source.getLastName())) {
            receiver.setLastName(source.getLastName());
        }

        if (!receiver.getPhotoUrl().equals(source.getPhotoUrl())) {
            receiver.setPhotoUrl(source.getPhotoUrl());
        }

        if (!receiver.getEmail().equals(source.getEmail())) {
            receiver.setEmail(source.getEmail());
        }

        if (!receiver.getAbout().equals(source.getAbout())) {
            receiver.setAbout(source.getAbout());
        }
        save(receiver);
    }

    /**
     * Returns true if specified question author is current user.
     * @param q question.
     * @param u current user.
     * @return true of false.
     */
    public boolean isUsersQuestion(Question q, Principal u) {
        if (u == null) {
            return false;
        }

        User user = getUser(u);
        if (user.equals(q.getAuthor())) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Subscribe current user to specified tag if not already subscribed.
     * @param p current user.
     * @param tagName tag name to subscribe.
     * @return true if success and false else.
     */
    public boolean subscribeToTag(Principal p, String tagName) {
        Tag tag = tagsService.getTagByName(tagName);
        User user = getUser(p);

        if (user.subscribedToTag(tag)) {
            return false;
        }

        user.getTags().add(tag);
        save(user);
        return true;
    }
}
